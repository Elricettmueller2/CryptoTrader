===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/backend/main.py =====
from fastapi.middleware.cors import CORSMiddleware
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
import ccxt
import ccxt.async_support as ccxt_async
import logging
from urllib.parse import unquote
from datetime import datetime
import asyncio


app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Frontend origin
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

logging.basicConfig(level=logging.INFO)

@app.get("/live-data/{pair:path}")
async def get_live_data(pair: str):
    decoded_pair = unquote(pair)
    logging.info(f"Decoded pair: {decoded_pair}")
    return {"pair_received": decoded_pair}

@app.websocket("/ws/{pair:path}")
async def websocket_endpoint(websocket: WebSocket, pair: str):
    await websocket.accept()
    decoded_pair = unquote(pair)
    formatted_pair = decoded_pair  # Use the pair as is

    exchange = ccxt_async.binance()

    try:
        markets = await exchange.load_markets()
        if formatted_pair not in markets:
            await websocket.send_json({'error': f"Market {formatted_pair} not found"})
            return  # Exit to prevent further execution
        while True:
            ticker = await exchange.fetch_ticker(formatted_pair)
            await websocket.send_json({
                'timestamp': ticker['timestamp'],
                'last': ticker['last'],
                'bid': ticker['bid'],
                'ask': ticker['ask'],
                'high': ticker['high'],
                'low': ticker['low'],
                'volume': ticker['baseVolume'],
            })
            await asyncio.sleep(1)
    except WebSocketDisconnect:
        logging.info("WebSocket disconnected")
    except Exception as e:
        logging.error(f"Error in WebSocket: {e}")
    finally:
        await exchange.close()


@app.get("/markets")
async def get_markets():
    try:
        exchange = ccxt.binance()
        markets = exchange.load_markets()
        available_markets = list(markets.keys())
        logging.info(f"Markets fetched: {available_markets}")  # Log the markets fetched
        return {"available_markets": available_markets}
    except Exception as e:
        logging.error(f"Error loading markets: {e}")
        return {"error": str(e)}


@app.get("/historical-data/{pair:path}")
async def get_historical_data(pair: str, timeframe: str = "1h", start_date: str = None, end_date: str = None):
    decoded_pair = unquote(pair)
    formatted_pair = decoded_pair.replace('/', '')  # Convert 'BTC/USDT' to 'BTCUSDT'
    
    exchange = ccxt.binance()
    since = exchange.parse8601(start_date) if start_date else None
    until = exchange.parse8601(end_date) if end_date else None

    logging.info(f"Fetching historical data for pair: {formatted_pair}, timeframe: {timeframe}, since: {start_date}, until: {end_date}")

    try:
        ohlcv = exchange.fetch_ohlcv(
            symbol=formatted_pair,
            timeframe=timeframe,
            since=since,
            limit=1000
        )
        logging.info(f"Data fetched for pair {formatted_pair}: {ohlcv}")
        return {"pair": formatted_pair, "data": ohlcv}
    except Exception as e:
        logging.error(f"Error fetching historical data: {e}")
        return {"error": str(e)}


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/backend/strategies/__init__.py =====
# strategies/__init__.py

from .base_strategy import BaseStrategy
from .moving_average_crossover import MovingAverageCrossoverStrategy
from .rsi_strategy import RSIStrategy
from .sma_strategy import SimpleMovingAverageStrategy  # Import the new strategy

STRATEGY_REGISTRY = {
    'moving_average_crossover': MovingAverageCrossoverStrategy,
    'rsi': RSIStrategy,
    'simple_moving_average': SimpleMovingAverageStrategy,  # Add the SMA strategy
}


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/backend/strategies/moving_average_crossover.py =====
# strategies/moving_average_crossover.py

import pandas as pd
import numpy as np
from .base_strategy import BaseStrategy

class MovingAverageCrossoverStrategy(BaseStrategy):
    def __init__(self, short_window=50, long_window=200):
        self.short_window = short_window
        self.long_window = long_window

    def generate_signals(self, data):
        signals = pd.DataFrame(index=data.index)
        signals['signal'] = 0.0

        # Calculate short and long moving averages
        signals['short_mavg'] = data['close'].rolling(window=self.short_window, min_periods=1).mean()
        signals['long_mavg'] = data['close'].rolling(window=self.long_window, min_periods=1).mean()

        # Avoid chained assignment by using .iloc or .loc properly
        condition = signals['short_mavg'].iloc[self.short_window:] > signals['long_mavg'].iloc[self.short_window:]
        signals.loc[signals.index[self.short_window:], 'signal'] = np.where(condition, 1.0, 0.0)

        # Generate trading orders (buy = 1, sell = -1)
        signals['positions'] = signals['signal'].diff()

        # Ensure no NaN values in the signals
        signals = signals.fillna(0)

        return signals

    def execute_trades(self):
        pass

    def analyze_performance(self):
        pass


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/backend/strategies/sma_strategy.py =====
# strategies/sma_strategy.py

import pandas as pd
import numpy as np
from .base_strategy import BaseStrategy

class SimpleMovingAverageStrategy(BaseStrategy):
    def __init__(self, window=50):
        self.window = window

    def generate_signals(self, data):
        signals = pd.DataFrame(index=data.index)
        signals['signal'] = 0.0

        # Ensure no NaN values in the data (ffill and bfill to fill missing values)
        data['close'] = data['close'].ffill().bfill()

        # Calculate the simple moving average (SMA)
        sma = data['close'].rolling(window=self.window, min_periods=1).mean()

        # Buy when price is above the SMA, sell when price is below
        signals['signal'] = np.where(data['close'] > sma, 1.0, -1.0)

        # Debug: Check for NaN values in the signals
        if signals.isnull().any().any():
            print("There are NaN values in the signals after processing.")

        # Fill NaN values in signals with 0 to ensure valid output
        signals = signals.fillna(0)

        # Generate trading orders (buy = 1, sell = -1)
        signals['positions'] = signals['signal'].diff()

        return signals

    def execute_trades(self):
        """Not implemented: this function will execute live trades."""
        pass

    def analyze_performance(self):
        """Performance analysis will be handled by the backtester."""
        pass


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/backend/strategies/rsi_strategy.py =====
# strategies/rsi_strategy.py

import pandas as pd
import numpy as np
from .base_strategy import BaseStrategy

class RSIStrategy(BaseStrategy):
    def __init__(self, window=14, buy_threshold=30, sell_threshold=70):
        self.window = window
        self.buy_threshold = buy_threshold
        self.sell_threshold = sell_threshold

    def generate_signals(self, data):
        signals = pd.DataFrame(index=data.index)
        signals['signal'] = 0.0

        # Ensure no NaN values in the data (use ffill and bfill as recommended)
        data['close'] = data['close'].ffill().bfill()

        # Calculate the Relative Strength Index (RSI)
        delta = data['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=self.window).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=self.window).mean()

        # Avoid division by zero or NaN in RSI calculation
        rs = gain / loss
        rs = rs.replace([np.inf, -np.inf], 0)  # Replace any infinite values with 0
        rsi = 100 - (100 / (1 + rs))

        # Check for NaN values in RSI and handle them
        rsi = rsi.fillna(50)  # Set neutral RSI value for missing data

        # Debug: Check for NaN in RSI values
        if rsi.isnull().any():
            print("There are NaN values in the RSI calculation.")

        # Buy signal when RSI is below buy_threshold
        signals['signal'] = np.where(rsi < self.buy_threshold, 1.0, 0.0)

        # Sell signal when RSI is above sell_threshold
        signals['signal'] = np.where(rsi > self.sell_threshold, -1.0, signals['signal'])

        # Generate trading orders (buy = 1, sell = -1)
        signals['positions'] = signals['signal'].diff()

        # Debug: Check for NaN values in the signals
        if signals.isnull().any().any():
            print("There are NaN values in the signals after processing.")
        
        return signals

    def execute_trades(self):
        """Not implemented: this function will execute live trades."""
        pass

    def analyze_performance(self):
        """Performance analysis will be handled by the backtester."""
        pass


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/backend/backtesting/__init__.py =====


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/backend/backtesting/backtester.py =====
# backtesting/backtester.py

import pandas as pd

class Backtester:
    def __init__(self, strategy, data, initial_capital=10000.0):
        self.strategy = strategy
        self.data = data
        self.initial_capital = initial_capital
        self.positions = None
        self.portfolio = None

    def run_backtest(self):
        signals = self.strategy.generate_signals(self.data)

        # Ensure no NaN values in signals before proceeding
        signals = signals.fillna(0)

        self.positions = signals['signal']

        # Debug: Check if any positions were created
        print(f"Total positions generated: {self.positions.sum()}")

        # Calculate portfolio performance
        self.calculate_portfolio_performance(signals)

        # Debug: Check initial portfolio value
        if self.portfolio['total'].iloc[0] == 0:
            print("Initial portfolio value is 0, which causes division by zero in performance calculations.")
        if self.positions.sum() == 0:
            print("No positions were generated during the backtest, hence no trades were made.")

        return self.portfolio

    def calculate_portfolio_performance(self, signals):
        positions = pd.DataFrame(index=signals.index).fillna(0.0)
        positions['positions'] = signals['positions']
        
        # Calculate cumulative positions held (number of units)
        positions['cum_positions'] = positions['positions'].cumsum()
        
        # Ensure cumulative positions are not negative (no short selling)
        positions['cum_positions'] = positions['cum_positions'].clip(lower=0)
        
        # Calculate holdings and cash
        portfolio = pd.DataFrame(index=positions.index)
        portfolio['holdings'] = positions['cum_positions'] * self.data['close']
        trade_value = positions['positions'] * self.data['close']
        portfolio['cash'] = self.initial_capital - trade_value.cumsum()
        
        # Ensure cash doesn't go negative
        portfolio['cash'] = portfolio['cash'].clip(lower=0)
        
        portfolio['total'] = portfolio['cash'] + portfolio['holdings']
        portfolio['returns'] = portfolio['total'].pct_change().fillna(0)
        
        self.portfolio = portfolio



===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/backend/backtesting/performance.py =====
# backtesting/performance.py

import numpy as np

def calculate_performance_metrics(portfolio, risk_free_rate=0.0):
    returns = portfolio['returns']
    total_return = portfolio['total'][-1] / portfolio['total'][0] - 1
    annualized_return = np.mean(returns) * 252
    annualized_volatility = np.std(returns) * np.sqrt(252)
    sharpe_ratio = (annualized_return - risk_free_rate) / annualized_volatility
    max_drawdown = calculate_max_drawdown(portfolio['total'])
    metrics = {
        'Total Return': total_return,
        'Annualized Return': annualized_return,
        'Annualized Volatility': annualized_volatility,
        'Sharpe Ratio': sharpe_ratio,
        'Max Drawdown': max_drawdown,
    }
    return metrics

def calculate_max_drawdown(total_portfolio_value):
    cumulative_max = total_portfolio_value.cummax()
    drawdown = (total_portfolio_value - cumulative_max) / cumulative_max
    max_drawdown = drawdown.min()
    return max_drawdown



===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/backend/data/__init__.py =====
from .data_loader import fetch_historical_data

===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/backend/data/data_loader.py =====
# data/data_loader.py

import ccxt
import pandas as pd

def fetch_historical_data(pair, timeframe='1d', since=None, limit=1000):
    exchange = ccxt.binance()
    ohlcv = exchange.fetch_ohlcv(symbol=pair, timeframe=timeframe, since=since, limit=limit)
    data = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    data['timestamp'] = pd.to_datetime(data['timestamp'], unit='ms')
    data.set_index('timestamp', inplace=True)

    # Fill missing data (forward and backward fill to avoid NaNs)
    data = data.ffill().bfill()

    # Check for any remaining NaN values
    if data.isnull().any().any():
        print("There are still NaN values in the data after filling.")

    return data


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/backend/utils/__init__.py =====


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/App.js =====
import React from 'react';
import Markets from './components/Markets';
import Dashboard from './components/Dashboard';  // Assuming Dashboard has the chart component

// App.js
function App() {
    return (
        <div>
            <h1>Crypto Trading Platform</h1>
            <Markets />
            <Dashboard />
        </div>
    );
}


export default App;


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/index.js =====
import React from 'react';
import { createRoot } from 'react-dom/client';  // Import createRoot from React 18
import App from './App';

const container = document.getElementById('root');  // Get the root element
const root = createRoot(container);  // Create a React 18 root

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/apiService.js =====
// src/apiService.js
import axios from 'axios';

const api = axios.create({
    baseURL: 'http://localhost:8000',  // Ensure the base URL is correct
});


export async function fetchMarkets() {
    try {
        const response = await api.get('/markets');
        console.log("Full response from backend /markets:", response);  // Log the full response object
        console.log("Available markets in response:", response.data.available_markets);  // Log specifically the markets data
        return response.data.available_markets || [];  // Ensure the response is an array, or return an empty array
    } catch (error) {
        console.error("Error fetching markets:", error);
        return [];  // Return an empty array in case of an error
    }
}







export const fetchLiveData = async (pair) => {
    try {
        const response = await api.get(`/live-data/${encodeURIComponent(pair)}`);
        return response.data;
    } catch (error) {
        console.error('Error fetching live data:', error);
        return null;
    }
};

// Corrected fetchHistoricalData function in apiService.js
export const fetchHistoricalData = async (pair, timeframe, startDate, endDate) => {
    // Remove the '/' in the pair symbol (e.g., BTC/USDT becomes BTCUSDT)
    const formattedPair = pair.replace('/', '');

    try {
        const response = await api.get(`/historical-data/${encodeURIComponent(formattedPair)}`, {
            params: {
                timeframe,
                start_date: startDate,
                end_date: endDate,
            },
        });
        console.log("Historical data response:", response.data);  // Log the response for debugging
        return response.data;  // Return the data from the backend
    } catch (error) {
        console.error('Error fetching historical data:', error);  // Handle error
        return null;
    }
};





===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/components/Chart.js =====
// src/components/Chart.js
import React from 'react';
import Plot from 'react-plotly.js';

const Chart = ({ data, layout }) => {
    console.log('Chart component received data:', data);
    console.log('Chart component received layout:', layout);

    return (
        <div>
            <Plot
                data={data}
                layout={{ ...layout, autosize: true }}
                style={{ width: '100%', height: '100%' }}
                config={{ responsive: true, scrollZoom: true }}
                useResizeHandler={true}
            />
        </div>
    );
};

export default Chart;


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/components/Markets.js =====
import React, { useEffect, useState } from 'react';
import { fetchMarkets } from '../apiService';

function Markets() {
    const [markets, setMarkets] = useState([]);  // Original list of markets
    const [filteredMarkets, setFilteredMarkets] = useState([]);  // Filtered and sorted markets
    const [searchQuery, setSearchQuery] = useState('');  // Search query state
    const [sortOrder, setSortOrder] = useState('asc');  // Sorting order
    const [loading, setLoading] = useState(true);  // Loading state
    const [error, setError] = useState(null);  // Error state
    const [visibleCount, setVisibleCount] = useState(10);  // Number of markets to display initially

    // Fetch markets from the API once on component mount
    useEffect(() => {
        const getMarkets = async () => {
            try {
                const data = await fetchMarkets();
                if (data && Array.isArray(data)) {
                    setMarkets(data);
                    setFilteredMarkets(data);  // Initially, show all markets
                    console.log("Markets fetched:", data);
                } else {
                    setError("Invalid markets data format");
                }
            } catch (error) {
                console.error("Error fetching markets:", error);
                setError("Failed to load markets");
            } finally {
                setLoading(false);
            }
        };

        getMarkets();
    }, []);

    // Handle search input change and filter the markets based on the search query
    useEffect(() => {
        const filtered = markets.filter((market) =>
            market.toLowerCase().includes(searchQuery.toLowerCase())
        );
        setFilteredMarkets(filtered);  // Update filtered markets based on search query
        setVisibleCount(10);  // Reset the visible count when searching
    }, [searchQuery, markets]);

    // Sorting logic
    const handleSort = (order) => {
        const sortedMarkets = [...filteredMarkets].sort((a, b) => {
            return order === 'asc' ? a.localeCompare(b) : b.localeCompare(a);
        });
        setSortOrder(order);
        setFilteredMarkets(sortedMarkets);  // Update the filtered markets after sorting
    };

    // Function to load more markets
    const loadMore = () => {
        setVisibleCount((prevCount) => prevCount + 10);  // Show 10 more markets each time
    };

    if (loading) {
        return <p>Loading markets...</p>;
    }

    if (error) {
        return <p>{error}</p>;
    }

    return (
        <div>
            <h2>Available Markets</h2>

            {/* Search bar */}
            <input
                type="text"
                placeholder="Search markets..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}  // Update search query
                style={{ marginBottom: '20px', padding: '10px', width: '100%' }}
            />

            {/* Sorting buttons */}
            <div>
                <button onClick={() => handleSort('asc')}>Sort A-Z</button>
                <button onClick={() => handleSort('desc')}>Sort Z-A</button>
            </div>

            {/* Display limited filtered markets */}
            <ul>
                {filteredMarkets.slice(0, visibleCount).map((market, index) => (
                    <li key={index}>{market}</li>
                ))}
            </ul>

            {/* Show Load More button if there are more markets to display */}
            {visibleCount < filteredMarkets.length && (
                <button onClick={loadMore} style={{ marginTop: '20px' }}>
                    Load More
                </button>
            )}
        </div>
    );
}

export default Markets;


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/components/PriceTicker.js =====
import React, { useState, useEffect } from 'react';
import { fetchLiveData } from '../apiService';

const PriceTicker = ({ market }) => {
    const [price, setPrice] = useState(null);

    useEffect(() => {
        const fetchData = async () => {
            const data = await fetchLiveData(market);
            if (data && data.pair_received) {
                setPrice(data.price); // Assume price is part of the API response
            }
        };

        fetchData();
        const interval = setInterval(fetchData, 5000); // Update every 5 seconds

        return () => clearInterval(interval);
    }, [market]);

    return (
        <div>
            <h2>Live Price for {market}: {price ? `$${price}` : 'Loading...'}</h2>
        </div>
    );
};

export default PriceTicker;


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/components/fetchMarkets.js =====


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/components/Dashboard.js =====
// src/components/Dashboard.js
import React, { useState, useEffect, useRef } from 'react';
import Chart from './Chart';
import MarketSelector from './MarketSelector';


const Dashboard = () => {
    const [liveData, setLiveData] = useState([]);
    const [selectedPair, setSelectedPair] = useState('BTC/USDT');
    const ws = useRef(null);

    // Connect to WebSocket when selectedPair changes
    useEffect(() => {
        if (ws.current) {
            ws.current.close();
        }

        ws.current = new WebSocket(`ws://localhost:8000/ws/${encodeURIComponent(selectedPair)}`);

        ws.current.onopen = () => {
            console.log('WebSocket connection opened');
        };

        ws.current.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log('Received data:', data);

            setLiveData((prevData) => {
                const newData = [...prevData, data];
                // Limit data to the last 1000 points
                if (newData.length > 1000) {
                    newData.shift();
                }
                return newData;
            });
        };

        ws.current.onerror = (error) => {
            console.error('WebSocket error:', error);
        };

        ws.current.onclose = () => {
            console.log('WebSocket connection closed');
        };

        // Cleanup on unmount or pair change
        return () => {
            if (ws.current) {
                ws.current.close();
            }
        };
    }, [selectedPair]);

    // Prepare data for the chart
    const chartData = [
        {
            x: liveData.map((d) => new Date(d.timestamp)),
            y: liveData.map((d) => d.last),
            type: 'scatter',
            mode: 'lines',
            line: { color: 'blue' },
        },
    ];

    const layout = {
        title: `${selectedPair} Live Price`,
        xaxis: { title: 'Time' },
        yaxis: { title: 'Price' },
    };

    const handleMarketSelect = (market) => {
        setSelectedPair(market);
        setLiveData([]);
    };
    

    

    return (
        <div>
            <h2>{selectedPair} Live Chart</h2>
            <MarketSelector onMarketSelect={handleMarketSelect} />
            <Chart data={chartData} layout={layout} />
        </div>
    );
};


export default Dashboard;


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/components/Header.js =====


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/components/LiveData.js =====


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/components/MarketList.js =====
// src/components/MarketList.js
import React, { useEffect, useState } from 'react';
import { fetchMarkets } from '../apiService';

const MarketList = () => {
    const [markets, setMarkets] = useState([]);

    useEffect(() => {
        const getMarkets = async () => {
            const data = await fetchMarkets();
            setMarkets(data);
        };
        getMarkets();
    }, []);

    return (
        <div>
            <h2>Available Markets</h2>
            <ul>
                {markets.map((market, index) => (
                    <li key={index}>{market}</li>
                ))}
            </ul>
        </div>
    );
};

export default MarketList;


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/components/MarketSelector.js =====
  // src/components/MarketSelector.js
import React, { useState, useEffect } from 'react';
import { fetchMarkets } from '../apiService';

const MarketSelector = ({ onMarketSelect }) => {
    const [markets, setMarkets] = useState([]);
    const [selectedMarket, setSelectedMarket] = useState('BTC/USDT');

    useEffect(() => {
        const getMarkets = async () => {
            const availableMarkets = await fetchMarkets();
            setMarkets(availableMarkets);
        };
        getMarkets();
    }, []);

    const handleChange = (e) => {
        const market = e.target.value;
        setSelectedMarket(market);
        if (onMarketSelect) {
            onMarketSelect(market);
        }
    };

    return (
        <div>
            <h3>Select a Market</h3>
            <select value={selectedMarket} onChange={handleChange}>
                {markets.map((market, index) => (
                    <option key={index} value={market}>
                        {market}
                    </option>
                ))}
            </select>
        </div>
    );
};

export default MarketSelector;


===== /Users/elricettmuller/Programming/trading_platform/CryptoTrader/frontend/src/components/SettingsPanel.js =====


